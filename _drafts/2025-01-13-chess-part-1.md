---
layout: post
title: 'Writing a Chess Engine (Part 1)'
---

I know _how_ to play chess, but I'm not very good at it.
Will writing a chess engine help me get better?
Most likely not, but it is an interesting diversion, and maybe I'll play a few
more games than I would have in the process.

Now I know a little about search, and about how a simple search-based engine
might operate.
Here's how I think it will work:

- When it's the computer's turn to move, it will search a tree of boards,
  looking for its most promising move.
- The tree has the current board as its root, and the descendants of a node are
  those boards that result from any legal move taken on the current board (by
  the player whose turn it is).
- The tree is very large (infinite, in fact), so it will only consider some
  initial subtree.
- So each available move leads to a tree of _possible futures_.
- A move is considered more promising if it leads to futures in which the
  machine is likely to capture more (and more valuable) pieces while losing
  fewer (and less valuable) pieces.
- When evaluating the cost of a move, the machine also needs to account for the
  fact that the human player is likely to make moves that benefit _themself_ the
  most as well.

There's a lot left to figure out here, but that's enough to get started.

## Representation

The first thing I'll do is represent a board with pieces on it.
There are lots of choices here, but I'm going to start with a simple vector of
pairs, where each pair is a piece and its position:

```rust
#[derive(Debug)]
pub struct Board(Vec<(Piece, Pos)>);
```

As a general rule, types should make illegal states unrepresentable.
That's unfortunately not the case here: there's nothing stopping a board from
having 8 kings, two pieces on the same square, or no pieces at all, for
instance.
If that bites us later we can always change the representation then.

A `Piece` consists of a _kind_ (pawn, bishop, knight, rook, queen, king) and a
color (black or white):

```rust
#[derive(Debug, Clone, Copy)]
pub struct Piece {
    kind: PieceKind,
    color: Color,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum PieceKind {
    Pawn,
    Bishop,
    Knight,
    Rook,
    Queen,
    King,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Color {
    Black,
    White,
}
```

Positions use the standard format of a _file-rank_ pair, where the files run a-h
and the ranks 1-8:

```rust
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Pos(pub File, pub Rank);

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum File {
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Rank {
    R1,
    R2,
    R3,
    R4,
    R5,
    R6,
    R7,
    R8,
}
```

(The files are the x coordinates and the ranks are the y coordinates.
I always get this backward because the English expression "rank and file" puts
them in the opposite order of an `(x, y)` pair.)

We can implement the `Default` trait for `Board`, returning the board that
starts a game.

```rust
macro_rules! piece {
    ($kind: ident, $color: ident, $file: ident, $rank: ident) => {
        (Piece::new($kind, $color), Pos($file, $rank))
    };
}

impl Default for Board {
    fn default() -> Self {
        use Color::*;
        use File::*;
        use PieceKind::*;
        use Rank::*;

        Board(vec![
            // White
            piece!(Pawn, White, A, R2),
            piece!(Pawn, White, B, R2),
            piece!(Pawn, White, C, R2),
            piece!(Pawn, White, D, R2),
            piece!(Pawn, White, E, R2),
            piece!(Pawn, White, F, R2),
            piece!(Pawn, White, G, R2),
            piece!(Pawn, White, H, R2),
            piece!(Rook, White, A, R1),
            piece!(Knight, White, B, R1),
            piece!(Bishop, White, C, R1),
            piece!(Queen, White, D, R1),
            piece!(King, White, E, R1),
            piece!(Bishop, White, F, R1),
            piece!(Knight, White, G, R1),
            piece!(Rook, White, H, R1),
            // Black
            piece!(Pawn, Black, A, R7),
            piece!(Pawn, Black, B, R7),
            piece!(Pawn, Black, C, R7),
            piece!(Pawn, Black, D, R7),
            piece!(Pawn, Black, E, R7),
            piece!(Pawn, Black, F, R7),
            piece!(Pawn, Black, G, R7),
            piece!(Pawn, Black, H, R7),
            piece!(Rook, Black, A, R8),
            piece!(Knight, Black, B, R8),
            piece!(Bishop, Black, C, R8),
            piece!(Queen, Black, D, R8),
            piece!(King, Black, E, R8),
            piece!(Bishop, Black, F, R8),
            piece!(Knight, Black, G, R8),
            piece!(Rook, Black, H, R8),
        ])
    }
}
```

Here I've used a really simple `piece` macro to save a little bit of repetitive
typing.

## Printing a Board

As a first step, let's just print a board.
I'll do this via the `Display` trait, although I'm not totally sure if this is
idiomatic (maybe this is more of a `Debug` operation?).

```rust
use std::fmt;

// ...

impl fmt::Display for Board {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Iterate over ranks and files.
        // Check if there's a piece on the current square, and print its name if
        // so.
        todo!()
    }
}
```

So we need a way to iterate over ranks and files in order.
This sounds like a job for the `Iterator` trait.
Now the `File` and `Rank` types won't implement `Iterator`; instead we'll write
a method for each that returns a different struct that does.
For `File`:

```rust
impl File {
    pub fn in_order() -> FileIter {
        FileIter {
            current: Some(File::A),
        }
    }
}

pub struct FileIter {
    current: Option<File>,
}

impl Iterator for FileIter {
    type Item = File;

    fn next(&mut self) -> Option<Self::Item> {
        use File::*;
        let next = match self.current {
            Some(A) => Some(B),
            Some(B) => Some(C),
            Some(C) => Some(D),
            Some(D) => Some(E),
            Some(E) => Some(F),
            Some(F) => Some(G),
            Some(G) => Some(H),
            _ => None,
        };
        std::mem::replace(&mut self.current, next)
    }
}
```

A `FileIter` holds the current state of the iterator, and the `next` method on
`FileIter` simply advances to the next file each time it's called.
Would it be better to implement [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)
on `File`, returning `FileIter`?
I'm not sure, but it doesn't matter at this point.

Here's the same treatment for `Rank`:

```rust
impl Rank {
    pub fn in_order() -> RankIter {
        RankIter {
            current: Some(Rank::R1),
        }
    }
}

pub struct RankIter {
    current: Option<Rank>,
}

impl Iterator for RankIter {
    type Item = Rank;

    fn next(&mut self) -> Option<Self::Item> {
        use Rank::*;
        let next = match self.current {
            Some(R1) => Some(R2),
            Some(R2) => Some(R3),
            Some(R3) => Some(R4),
            Some(R4) => Some(R5),
            Some(R5) => Some(R6),
            Some(R6) => Some(R7),
            Some(R7) => Some(R8),
            _ => None,
        };
        std::mem::replace(&mut self.current, next)
    }
}
```

While we're thinking about coordinates, let's implement `Display` for `File` and
`Rank` as well:

```rust
impl fmt::Display for File {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use File::*;
        let text = match self {
            A => "a",
            B => "b",
            C => "c",
            D => "d",
            E => "e",
            F => "f",
            G => "g",
            H => "h",
        };
        write!(f, "{}", text)
    }
}

impl fmt::Display for Rank {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use Rank::*;
        let text = match self {
            R1 => "1",
            R2 => "2",
            R3 => "3",
            R4 => "4",
            R5 => "5",
            R6 => "6",
            R7 => "7",
            R8 => "8",
        };
        write!(f, "{}", text)
    }
}
```

At this point we can do things like:

```rust
for file in File::in_order() {
    println!("{}", file);
}
for rank in Rank::in_order() {
    println!("{}", rank);
}
// a
// b
// c
// d
// e
// f
// g
// h
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
```

This lets us make a little more progress on displaying a `Board`:

```rust
impl fmt::Display for Board {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for rank in Rank::in_order() {
            for file in File::in_order() {
                // Is there a piece at this location?
            }
            write!(f, "\n")?;
        }
        Ok(())
    }
}
```

So we need to be able to query a board to get the piece at an arbitrary position.
I'll write a method named `at` that does this:

```rust
impl Board {
    pub fn at(&self, pos: Pos) -> Option<(Piece, Pos)> {
        self.0.iter().find(|p| p.1 == pos).copied()
    }
}
```

I considered using the [`std::ops::Index`](https://doc.rust-lang.org/std/ops/trait.Index.html)
trait here, but the return type doesn't seem amenable for what we're trying to
do: the associated `index` function requires us to return a _reference_ to the
`Output` type, and I don't see any way to do that here (since we construct the
`Option` within the function).

With `Board.at`, we're almost done with our `Display` implementation:

```rust
impl fmt::Display for Board {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for rank in Rank::in_order() {
            for file in File::in_order() {
                if let Some((piece, _)) = self.at(Pos(file, rank)) {
                    write!(f, "{}", piece)?;
                } else {
                    write!(f, " ")?;
                }
            }
            write!(f, "\n")?;
        }
        Ok(())
    }
}
```

This won't work quite yet; we just need to implement `Display` for `Piece`:

```rust
impl fmt::Display for Piece {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use Color::*;
        use PieceKind::*;

        let text = match self.color {
            Black => match self.kind {
                Pawn => "p",
                Bishop => "b",
                Knight => "n",
                Rook => "r",
                Queen => "q",
                King => "k",
            },
            White => match self.kind {
                Pawn => "P",
                Bishop => "B",
                Knight => "N",
                Rook => "R",
                Queen => "Q",
                King => "K",
            },
        };
        write!(f, "{}", text)
    }
}
```

I've chosen to represent black pieces using lowercase letters, and white pieces
using uppercase.
I'm not sure if this is standard or not, but I _am_ using the standard
["Algebraic Notation"](https://en.wikipedia.org/wiki/Chess#Notation) names for
the pieces.

Let's see how our `Display` trait performs:

```rust
let b = Board::default();
println!("{}", b);
// RNBQKBNR
// PPPPPPPP
//
//
//
//
// pppppppp
// rnbqkbnr
//
```

Well, that leaves a lot to be desired.

Let's improve it in a couple of ways:

- Render squares using `+`, `-`, and `|`.
- Show ranks and files along the border.

This requires a lot of fiddly code but none of it is difficult to write or
understand:

```rust
impl fmt::Display for Board {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "   ")?;
        for file in File::in_order() {
            write!(f, "  {} ", file)?;
        }
        write!(f, "\n")?;

        write!(f, "   ")?;
        for _ in 0..8 {
            write!(f, "+---")?;
        }
        write!(f, "+\n")?;

        for rank in Rank::in_order() {
            write!(f, " {} ", rank)?;
            for file in File::in_order() {
                if let Some((piece, _)) = self.at(Pos(file, rank)) {
                    write!(f, "| {} ", piece)?;
                } else {
                    write!(f, "|   ")?;
                }
            }
            write!(f, "| {}\n", rank)?;

            write!(f, "   ")?;
            for _ in 0..8 {
                write!(f, "+---")?;
            }
            write!(f, "+\n")?;
        }

        write!(f, "   ")?;
        for file in File::in_order() {
            write!(f, "  {} ", file)?;
        }
        Ok(())
    }
}
```

Much better:

```
     a   b   c   d   e   f   g   h
   +---+---+---+---+---+---+---+---+
 1 | R | N | B | Q | K | B | N | R | 1
   +---+---+---+---+---+---+---+---+
 2 | P | P | P | P | P | P | P | P | 2
   +---+---+---+---+---+---+---+---+
 3 |   |   |   |   |   |   |   |   | 3
   +---+---+---+---+---+---+---+---+
 4 |   |   |   |   |   |   |   |   | 4
   +---+---+---+---+---+---+---+---+
 5 |   |   |   |   |   |   |   |   | 5
   +---+---+---+---+---+---+---+---+
 6 |   |   |   |   |   |   |   |   | 6
   +---+---+---+---+---+---+---+---+
 7 | p | p | p | p | p | p | p | p | 7
   +---+---+---+---+---+---+---+---+
 8 | r | n | b | q | k | b | n | r | 8
   +---+---+---+---+---+---+---+---+
     a   b   c   d   e   f   g   h
```

Next, we'll start working on the "tree of moves" outlined at the beginning.
But that's enough for now.
