<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>A Little Gradient Descent</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
      rel="stylesheet"
    />

    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css" />
    <link rel="stylesheet" href="/assets/css/syntax.css" />

    
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
      integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib"
      crossorigin="anonymous"
    />
    
  </head>

  <body>
    <div id="content">
      <header>
        <nav>
          <a href="/">
            <img
              id="sonobe"
              src="/assets/images/sonobe.svg"
              alt="A sonobe module"
            />
          </a>

          <a href="/about">About</a>
        </nav>
      </header>

      <main><h1>A Little Gradient Descent</h1>

<p><img src="/assets/images/line-learning.gif" alt="A simple model learns a simple line" /></p>

<p>I’ve been increasingly interested in AI, so as an exercise I decided to play
around with some simple optimization problems using gradient descent.
I <em>really</em> thought I understood gradient descent, but my first attempts to get
something working were total failures.
For all my theoretical understanding, I didn’t really see how all of the pieces
fit together.
That, together with some bugs on the part of my autodiff implementation, made
for a frustrating morning.</p>

<p>In this note we’ll using gradient descent to train a tiny model to emulate a
linear function.
We’ll construct the entire system “from scratch”, so we’ll also see how
automatic differentation works.</p>

<h2 id="overview">Overview</h2>

<p>The GIF above illustrates well what we’re trying to do: the blue line is the
linear function we’d like to emulate, and the orange function shows the current
behavior of our model as it “learns” the blue line.
We’ll view this as an optimization problem, in which we want to optimize the
“nearness” of the orange line (our model’s behavior) to the blue line.
One simple way to measure this nearness is with <a href="https://en.wikipedia.org/wiki/Mean_squared_error">mean squared error</a>:
we pick some x values—say -2 and 3—calculate the value of our
“target” line and our model at those points, and combine them like so:</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi></mrow><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mi>M</mi><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>−</mo><mi>M</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{error} = \frac{(T(-2) - M(-2))^2 + (T(3) - M(3))^2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">error</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>

<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is our target function and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is our model.</p>

<p>The key observation here is that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{error}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathrm">error</span></span></span></span></span> is <em>a function of our
model’s parameters</em>.
Our goal is to find the values of the parameters so that the error is minimized.</p>

<h2 id="differentiation">Differentiation</h2>

<p>Gradient descent attacks this optimization problem by repeatedly calculating
little nudges for each parameter’s value.
And these updates are based on the <em>derivative</em> of the error with respect to
each parameter.
So we’re going to need a way to differentiate expressions.</p>

<p>There are many ways to implement automatic differentiation (“autodiff”), but
we’ll stick with a really simple approach here.
In particular, we’ll create a way to construct symbolic expressions involving,
numbers, variables, and arithmetic operations.
Differentiation is then just a simple recursive process, not too different from
evaluation.</p>

<p>We’ll represent expressions using a class <code class="language-plaintext highlighter-rouge">Expr</code>, which is a “sum” type having
two variants: “symbols” and “binary operations”:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Expr</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sym</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Construct a symbol, representing a variable.</span><span class="sh">"""</span>
        <span class="n">e</span> <span class="o">=</span> <span class="nc">Expr</span><span class="p">()</span>
        <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span>
        <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Construct an expression representing a binary operation.</span><span class="sh">"""</span>
        <span class="n">e</span> <span class="o">=</span> <span class="nc">Expr</span><span class="p">()</span>
        <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">=</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span>
        <span class="n">e</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">e</span><span class="p">.</span><span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="n">e</span><span class="p">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="k">return</span> <span class="n">e</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">Expr.sym('x')</code> creates an expression representing the variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, and
<code class="language-plaintext highlighter-rouge">Expr.bin('+', Expr.sym('x'), 2)</code>` represents <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">x + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>.</p>

<p>So an expression is either an instance of <code class="language-plaintext highlighter-rouge">Expr</code> or a Python number.</p>

<p>It will be convenient to be able to unpack <code class="language-plaintext highlighter-rouge">Expr</code> instances, so we’ll define <code class="language-plaintext highlighter-rouge">__iter__</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">iter</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">iter</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">op</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">rhs</span><span class="p">))</span>
</code></pre></div></div>

<p>and using our new unpacking ability, we’ll define <code class="language-plaintext highlighter-rouge">__str__</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span><span class="p">:</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">self</span>
        <span class="k">return</span> <span class="sa">f</span><span class="sh">"</span><span class="s">(</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="nf">str</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span>
</code></pre></div></div>

<p>This just renders <code class="language-plaintext highlighter-rouge">Expr</code> instances as S-Expressions.
Let’s see how it works:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">sym</span><span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">sym</span><span class="p">(</span><span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">)</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">,</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">'</span><span class="s">**</span><span class="sh">'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="c1"># =&gt; (+ (** x 2) (* x y))
</span></code></pre></div></div>

<p>Creating compound expressions using <code class="language-plaintext highlighter-rouge">Expr.bin(...)</code> is a pain.
Let’s define <code class="language-plaintext highlighter-rouge">__add__</code>, <code class="language-plaintext highlighter-rouge">__mul__</code>, etc. so that the above expression can be
created like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</code></pre></div></div>

<p>These do nothing more than dispatch to <code class="language-plaintext highlighter-rouge">Expr.bin</code> with the appropriate
arguments:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">bin</span><span class="p">(</span><span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>

<span class="c1"># ...
</span></code></pre></div></div>

<p>We’ll also define a convenient way to initialize variables:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Expr</span><span class="p">.</span><span class="nf">sym</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nf">map</span><span class="p">(</span><span class="n">Expr</span><span class="p">.</span><span class="n">sym</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
</code></pre></div></div>

<p>We can now define the example above very concisely like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">params</span><span class="p">(</span><span class="sh">"</span><span class="s">x y</span><span class="sh">"</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</code></pre></div></div>

<p>Our goal is to differentiate expressions like <code class="language-plaintext highlighter-rouge">e</code>.
This is actually very easy.
And that’s because, like evaluation, differentiation has a kind of
“compositional” quality to it.
What this means is that:</p>

<ul>
  <li>There are straightforward ways to compute the derivative of “simple”
expressions (like variables and numbers).</li>
  <li>In order to compute the derivative of a “compound” expression, you only need
to compute the derivatives of its components, and then “glue” them together in
some way.</li>
</ul>

<p>Now differentiation as we’ll implement it here is a function of two variables:
an <em>expression</em> and a <em>name</em>.
The result is the derivative of the expression <em>with respect to</em> the variable
with that name.</p>

<p>First, the simple rules for “atomic” expressions:</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo separator="true">,</mo><mi mathvariant="normal">_</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mtext> if </mtext><mi>y</mi><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mtext> otherwise</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{d}(\mathrm{number}, \_) &amp;= 0 \\

\mathrm{d}(y, x) &amp;=
\begin{cases}
  1 \textrm{ if } y = x \\
  0 \textrm{ otherwise}
\end{cases}
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-5.56em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">number</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mclose">)</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-5.56em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mord text"><span class="mord textrm"> if </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mord text"><span class="mord textrm"> otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>

<p>That is, the derivative of a number with respect to <em>any</em> variable is 0, and the
derivative of a variable with respect to another variable is 1 if they’re the
same or 0 if they’re not.</p>

<p>Now in python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Compute the derivative of the expression e w.r.t. the symbol whose name
    is x.</span><span class="sh">"""</span>
    <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># ...
</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>To compute the derivatives of binary expression, we need to implement the <em>chain
rule</em>.
This says that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>l</mi><mo>⊕</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">e = l \oplus r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>, then the derivative of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> w.r.t a
variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is:</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>l</mi></mrow></msub><mo>⋅</mo><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>+</mo><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>r</mi></mrow></msub><mo>⋅</mo><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\mathrm{d}(e, x) &amp;= \mathrm{d}_{el} \cdot \mathrm{d}(l, x) \\
  &amp;+ \mathrm{d}_{er} \cdot \mathrm{d}(r, x)
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span>

<p>This is compositionality in action: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{d}(l, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{d}(r, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
are just recursive calls to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathrm">d</span></span></span></span>.
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm{d}_{el}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm{d}_{er}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> depend on the particular operation
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span>.
For example, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>l</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">e = l + r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>l</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathrm{d}_{el} = \mathrm{d}_{er} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>,
whereas if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>l</mi><mo>⋅</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">e = l \cdot r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">\mathrm{d}_{el} = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">d</mi><mrow><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">\mathrm{d}_{er} = l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>.</p>

<p>In Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">e</span>

            <span class="n">dl_dx</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">dr_dx</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">de_dl</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">de_dr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">de_dl</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">de_dr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">de_dl</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">de_dr</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">de_dl</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">r</span>
                <span class="n">de_dr</span> <span class="o">=</span> <span class="o">-</span><span class="n">l</span> <span class="o">/</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">**</span><span class="sh">"</span><span class="p">:</span>
                <span class="c1"># Only nonnegative integer powers for now:
</span>                <span class="n">de_dl</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">l</span> <span class="o">**</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">de_dr</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="n">de_dl</span> <span class="o">*</span> <span class="n">dl_dx</span> <span class="o">+</span> <span class="n">de_dr</span> <span class="o">*</span> <span class="n">dr_dx</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Let’s try it out:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">params</span><span class="p">(</span><span class="sh">'</span><span class="s">x y</span><span class="sh">'</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="n">de_dx</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># =&gt; (+ (* 1 (+ (* (* 2 (** x 1)) 1) 0)) (* 1 (+ (* y 1) (* x 0))))
</span>
<span class="n">de_dy</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># =&gt; (+ (* 1 (+ (* (* 2 (** x 1)) 0) 0)) (* 1 (+ (* y 0) (* x 1))))
</span></code></pre></div></div>

<p>Yikes!
The result returned by <code class="language-plaintext highlighter-rouge">d</code> is an unsimplified mess, but it’s nonetheless
correct.</p>

<p>Finally, we’re going to need a way to <em>evaluate</em> expressions within some
“environment”.
Using <code class="language-plaintext highlighter-rouge">dict</code>s to represent environment, this is trivial:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Calculate the value of the expression e in the environment env.</span><span class="sh">"""</span>
    <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SYM</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">env</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">e</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="sh">"</span><span class="s">BIN</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">lv</span> <span class="o">=</span> <span class="nf">val</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="nf">val</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">+</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lv</span> <span class="o">+</span> <span class="n">rv</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lv</span> <span class="o">-</span> <span class="n">rv</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lv</span> <span class="o">*</span> <span class="n">rv</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lv</span> <span class="o">/</span> <span class="n">rv</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="sh">"</span><span class="s">**</span><span class="sh">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lv</span><span class="o">**</span><span class="n">rv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
</code></pre></div></div>

<p>We can now evaluate arbitrary expressions, including the results of
differentiation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>

<span class="nf">val</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="c1"># =&gt; 10
</span>
<span class="nf">val</span><span class="p">(</span><span class="n">de_dx</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="c1"># =&gt; 7
</span>
<span class="nf">val</span><span class="p">(</span><span class="n">de_dy</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="c1"># =&gt; 2
</span></code></pre></div></div>

<h2 id="back-to-optimization">…Back to Optimization</h2>

<p>We want to train a model to emulate a linear function.
Let’s use:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">target</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>as our target line.</p>

<p>Our model will be a linear function with two parameters: one for the slope and
the other for the y-intercept.
We define it as a function that returns an <em>expression</em>, which will allow us to
differentiate expressions built using it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">params</span><span class="p">(</span><span class="sh">"</span><span class="s">m b</span><span class="sh">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>Now our goal is to find values for <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">b</code> that make <code class="language-plaintext highlighter-rouge">model</code> behave like
<code class="language-plaintext highlighter-rouge">target</code>.
Let’s pretend we don’t know any better, and initialize them both to <code class="language-plaintext highlighter-rouge">0</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param_vals</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">m</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div></div>

<p>We can then <em>evaluate</em> our model at the current parameter values at any input
value using <code class="language-plaintext highlighter-rouge">val</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">model_val</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">val</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">)</span>
</code></pre></div></div>

<p>Finally, we’ll need some data to train our model on.
For this, we’ll just sample two points using our <code class="language-plaintext highlighter-rouge">target</code> line:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">train_xs</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">train_ys</span> <span class="o">=</span> <span class="p">[</span><span class="nf">target</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train_xs</span><span class="p">]</span>
</code></pre></div></div>

<p>Recall that we’re trying to optimize the <em>mean squared error</em> of our model
w.r.t. the target line.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">predictions</span> <span class="o">=</span> <span class="p">[</span><span class="nf">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train_xs</span><span class="p">]</span>
<span class="n">loss</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">((</span><span class="n">pi</span> <span class="o">-</span> <span class="n">yi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">train_ys</span><span class="p">))</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">train_xs</span><span class="p">)</span>
</code></pre></div></div>

<p>It’s important to note that <code class="language-plaintext highlighter-rouge">loss</code> is an <em>expression</em>.
Here’s what we get if we <code class="language-plaintext highlighter-rouge">print</code> it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
<span class="c1"># =&gt; (/ (+ (+ 0 (** (- (+ (* m -2) b) -3) 2)) (** (- (+ (* m 3) b) 7) 2)) 2)
</span></code></pre></div></div>

<p>An, as such, we can also <em>differentiate</em> it with respect to our parameters <code class="language-plaintext highlighter-rouge">m</code>
and <code class="language-plaintext highlighter-rouge">b</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dloss_dm</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="sh">'</span><span class="s">m</span><span class="sh">'</span><span class="p">)</span>
<span class="c1"># =&gt; (+ (* 0.5 (+ (* 1 (+ 0 (* 1 (+ (* (* 2 (** (- (+ (* m -2) b) -3) 1)) (+ (* 1 (+ (* 1 (+ -2 (* m 0))) 0)) 0)) 0)))) (* 1 (+ (* (* 2 (** (- (+ (* m 3) b) 7) 1)) (+ (* 1 (+ (* 1 (+ 3 (* m 0))) 0)) 0)) 0)))) (* (/ (- 0 (+ (+ 0 (** (- (+ (* m -2) b) -3) 2)) (** (- (+ (* m 3) b) 7) 2))) 4) 0))
</span>
<span class="n">dloss_db</span> <span class="o">=</span> <span class="nf">d</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="c1"># =&gt; (+ (* 0.5 (+ (* 1 (+ 0 (* 1 (+ (* (* 2 (** (- (+ (* m -2) b) -3) 1)) (+ (* 1 (+ (* 1 (+ 0 (* m 0))) 1)) 0)) 0)))) (* 1 (+ (* (* 2 (** (- (+ (* m 3) b) 7) 1)) (+ (* 1 (+ (* 1 (+ 0 (* m 0))) 1)) 0)) 0)))) (* (/ (- 0 (+ (+ 0 (** (- (+ (* m -2) b) -3) 2)) (** (- (+ (* m 3) b) 7) 2))) 4) 0))
</span></code></pre></div></div>

<h2 id="training">Training</h2>

<p>With <code class="language-plaintext highlighter-rouge">dloss_dm</code> and <code class="language-plaintext highlighter-rouge">dloss_db</code> in hand, training is straightforward.
We simply repeat the following steps with both <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">b</code> until we’re satisfied
with our error:</p>

<ol>
  <li>Calculate the derivative of the loss w.r.t. the parameter at the <em>current
parameter values</em>.</li>
  <li>Update the parameter’s value in the direction that <em>decreases</em> the loss
(locally); this means moving in the direction <em>opposite</em> the derivative
calculated in step (1).</li>
</ol>

<p>In practice, we don’t update the parameter values in fixed-sized steps, but
rather using some fraction of the derivative.
This fraction is usually called the <em>learning rate</em>.</p>

<p>Here’s what all this looks like in Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Learning rate and number of training iterations ("hyperparameters").
</span><span class="n">lr</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">n_iter</span> <span class="o">=</span> <span class="mi">20</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
    <span class="n">grad_m</span> <span class="o">=</span> <span class="nf">val</span><span class="p">(</span><span class="n">dloss_dm</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">)</span>
    <span class="n">grad_b</span> <span class="o">=</span> <span class="nf">val</span><span class="p">(</span><span class="n">dloss_db</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">)</span>

    <span class="n">param_vals</span><span class="p">[</span><span class="sh">"</span><span class="s">m</span><span class="sh">"</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">grad_m</span>
    <span class="n">param_vals</span><span class="p">[</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">]</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">grad_b</span>
</code></pre></div></div>

<p>Lo and behold, it works!</p>

<h2 id="gradient-descent-for-real">Gradient Descent, for Real</h2>

<p>What’s different in a <em>real</em> application that uses a standard package like
<code class="language-plaintext highlighter-rouge">pytorch</code>?
The most obvious differences are in how the autodiff functionality works.
For most interesting applications, the actual derivative expressions would be
unthinkably large.
The good news is that it’s not necessary to construct these expressions in the
first place.
That’s because in any given training iteration we’re only interested in the
derivative of the loss w.r.t. each parameter <em>at the current parameter values</em>.
We’ll go into the details in a future note, but the basic idea is to evaluate
the loss expression at the current parameter values, recording the parent-child
relationships of the expression in the process.
We then calculate derivatives
<a href="https://en.wikipedia.org/wiki/Backpropagation">“backwards”</a> from the root of
the expression towards the parameters.</p>

<p>This changes the look of our training loop:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
    <span class="c1"># Run loss function on current parameter values.
</span>    <span class="c1"># Backpropagate to calculate gradients.
</span>    <span class="c1"># Update parameter values.
</span></code></pre></div></div>

<p>A second difference is that in most real applications, we don’t consider the
entire dataset when calculating the loss, but instead work with batches of the
original dataset.
This has an important consequence: it means that the loss function being
optimized is actually <em>different</em> during different iterations of the training
loop.</p>

<p>It also changes our training loop:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># An "epoch" consists of however many training iterations it takes to process
# our training data once.
</span><span class="n">n_epochs</span> <span class="o">=</span> <span class="bp">...</span>

<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
  <span class="c1"># E.g. some function that randomly batches all our training data.
</span>  <span class="n">dl</span> <span class="o">=</span> <span class="nc">Dataloader</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">dl</span><span class="p">:</span>
      <span class="c1"># Calculate loss w.r.t. batch and current parameter values.
</span>      <span class="c1"># Backpropagate to calculate gradients.
</span>      <span class="c1"># Update parameter values.
</span></code></pre></div></div>

<h2 id="a-few-more-experiments">A Few More Experiments</h2>

<p>I tried repeating the above experiment with a quadratic function instead of a
line.
However, I really struggled to get the model to converge, even with more data
and more training iterations.
Using 3 datapoints:</p>

<p><img src="/assets/images/parabola-learning1.gif" alt="Regression with a parabola using 3 datapoints" /></p>

<p>And 10:</p>

<p><img src="/assets/images/parabola-learning2.gif" alt="Regression with a parabola using 10 datapoints" /></p>

<p>The loss would quickly drop only to bottom out above 0.
And if I increased the learning rate I’d run into overflow issues.</p>

<p>I finally logged some of the intermediate parameter values and realized that
they had very different “sensitivities”: the same learning rate was causing one
to oscillate wildly and another to just plod along.
I gave each parameter its <em>own</em> learning rate, tailored to the behavior I
observed above, and voila!</p>

<p><img src="/assets/images/parabola-learning3.gif" alt="Regression with a parabola using individualized learning rates" /></p>

</main>

      <footer></footer>
    </div>
  </body>
</html>
